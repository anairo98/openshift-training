{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the world of OpenShift","text":"<p>This guide is designed to help you get started with Red Hat OpenShift. Whether you're new to OpenShift or looking to solidify your foundational knowledge, this training will provide you with the basic concepts and hands-on experience needed to start to utilize Kubernetes effectively.</p>"},{"location":"#workshop-structure","title":"Workshop Structure","text":"<p>This workshop will start at the very beginning with very simple hands-on sessions and then build up step by step. At the end, participants should be able to get to grips with OpenShift.</p> <p>To get started, we will start with the basic objects in OCP. Thereby, the sessions 1 to 3 are based on a simple UseCase to make it easier to understand. After that we will continue to have a deeper look into different objects of OCP. Most of the sessions have tasks included, in which the participants have to troubleshoot some mistakes. By that, the participants of this workshop should be enabled to solve real-life problems and get a deeper understanding of the dependencies between the different objects.</p> <p>Here is short overview of the covered topics in each of the sessions (Disclaimer: Work in progress) </p> Session Description Content 1 to 3 Build up on a simple Use Case of a Boutique Online Shop Basic OCP objects, like Deployment, Services, Routes etc. ---------------- -------------------------------------------------------------------------------------------------------------------------------------- 4 Deploy a simple webserver by using an nginx image Containerfile, BuildConfigs, Builds, Images, Imagestreams etc."},{"location":"#prerequisites","title":"Prerequisites","text":"<p>Participants must have access to an Openshift cluster to carry out the hands-on tasks. Ideally, each participant uses their own namespace and can try out and test all exercises and tasks in it.</p>"},{"location":"#references-on-github","title":"References on GitHub","text":"<p>The whole GitHub Repository is linked below:</p> <p>OpenShift Trainings Repository</p>"},{"location":"#hands-on-labs","title":"Hands-On Labs","text":"<p>For the Hands-On Tasks thery will be a usecase provided. In the usecase, a simple web app is set up step by step as part of an online boutique store. The entire online store is made up of individual microservices.</p> <p>The microservices have to be connected to each other and made accessible with routes and services (everything else is covered in the specific tasks). The idea of the online boutique store is based on the GoogleCloudPlatform repository Original Source of Manifest Files</p>"},{"location":"#disclaimer","title":"Disclaimer","text":"<p>These Github pages are based on DevOps principles and are thereby, constantly developed and changed. This means that incomplete information or explanations and exercises that have not yet been fully described cannot be ruled out.</p> <p>Happy Learning!</p>"},{"location":"Session1/","title":"Use Case: E-Commerce Boutque Store","text":"<p>In this Hands-On-Labs, we deploy an e-commerce application, which is based on the Online Boutique, provided by Google Cloud Platform. </p> <p>The deployment manifests are modified so that they could be deployed on an OpenShift Cluster. The User Interface of \"Online Boutique\" looks like this:</p> <p></p>"},{"location":"Session1/#architecture","title":"Architecture","text":"<p>On the main page of the Online Boutique, a frontend service forwards the requests to the 10 corresponding backend services, as shown in this architectur image: </p> <p></p> <p>All these 11 microservices are communicating over gRPC protocol. </p>"},{"location":"Session1/#microservices","title":"Microservices","text":"<p>These 11 microservices are written in different programming languages and are responsible for a specific task in this e-commerce website:</p> Service Language Description frontend Go Exposes an HTTP server to serve the website. Does not require signup/login and generates session IDs for all users automatically. cartservice C# Stores the items in the user's shopping cart in Redis and retrieves it. productcatalogservice Go Provides the list of products from a JSON file and ability to search products and get individual products. currencyservice Node.js Converts one money amount to another currency. Uses real values fetched from European Central Bank. It's the highest QPS service. paymentservice Node.js Charges the given credit card info (mock) with the given amount and returns a transaction ID. shippingservice Go Gives shipping cost estimates based on the shopping cart. Ships items to the given address (mock) emailservice Python Sends users an order confirmation email (mock). checkoutservice Go Retrieves user cart, prepares order and orchestrates the payment, shipping and the email notification. recommendationservice Python Recommends other products based on what's given in the cart. adservice Java Provides text ads based on given context words. loadgenerator Python/Locust Continuously sends requests imitating realistic user shopping flows to the frontend."},{"location":"Session1/#prerequisites","title":"Prerequisites","text":"<p>Ensure that you have access to a OpenShift Cluster to deploy the manifests for the e-commerce application. </p> <p>Note</p> <p>If you do not already have access to a Demo Cluster, ask your training instructor! Or create a Demo Cluster by yourself via the following link: Red Hat Demo Cluster</p>"},{"location":"Session1/#lets-get-started-with-the-first-hands-on-session","title":"Lets get started with the first Hands-On Session","text":""},{"location":"Session1/#1-hands-on-lab","title":"1. Hands-On Lab","text":""},{"location":"Session1/#tasks","title":"Tasks","text":""},{"location":"Session1/#task-1-deployment","title":"Task 1: Deployment","text":"<ol> <li> <p>Create your own Namespace (like your own project)</p> <p></p> </li> <li> <p>Create the frontend Deployment by importing the yaml template</p> <ol> <li>Go to the Github Repository and navigate over the e-commerce folder to the frontend folder and then to the deployment.yml </li> <li>Copy the content of the deployment.yml </li> <li> <p>Switch to the Openshift Console and paste the content into the Import Yaml field</p> <p></p> </li> <li> <p>Click on Create and you will create the frontend deployment</p> </li> <li> <p>Go to Topology in Openshift Console and check on your newly created Pod</p> <p></p> </li> </ol> </li> <li> <p>There is some problem with your Pod, it is not running! Find out what the problem is about!?</p> <p>Do you need help?</p> <p>If you cannot solve the problem, switch to the Solutions for Troubleshooting chapter on this website (scroll down ) </p> </li> <li> <p>When you fixed the Problem, you maybe need to scale down and after that scale up your Pod again (so the changes are getting activated):</p> <p></p> </li> <li> <p>Give it a moment and wait until the Pod is running!</p> <p></p> </li> </ol>"},{"location":"Session1/#task-2-services","title":"Task 2: Services","text":"<ol> <li>Create a Service, which abstracts the frontend Deployment</li> <li> <p>Go to the Administrator view and search for services under the Networking section</p> <p></p> </li> <li> <p>Click on Create Service button</p> </li> <li> <p>Enter all necessary information</p> <p>Tip</p> <p>If you are unsure how to enter it, have a look at the following Yaml file: </p> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n\u00a0 name: frontend\n\u00a0 labels:\n\u00a0 \u00a0 app: frontend\nspec:\n\u00a0 type: ClusterIP\n\u00a0 selector:\n\u00a0 \u00a0 app: frontend\n\u00a0 ports:\n\u00a0 - name: http\n\u00a0 \u00a0 port: 80\n\u00a0 \u00a0 targetPort: 8080\n</code></pre> </li> <li> <p>Verify if the Service is linked to the prior created frontend Pod </p> <ol> <li>Click on the frontend Service</li> <li> <p>Click on the Pods section:</p> <p></p> </li> <li> <p>You can also verify by going back to the Topology section and click on the frontend Pod. There is now under the Resources section also the frontend Service linked</p> <p></p> </li> </ol> </li> </ol>"},{"location":"Session1/#task-3-routing","title":"Task 3: Routing","text":"<p>Create a Route by using the OpenShift UI  (not by using the manifest files given in the Github)</p> <ol> <li> <p>Go to Administrator view and click on Routes under the Networking section and click on the Create Route button</p> <p></p> </li> <li> <p>Give the Route a name: frontend</p> </li> <li>Select the correct frontend Service, which we created in Task 2</li> <li> <p>Select the correct Port (Service Port)  TargetPort (Port on the Container)</p> <p>Note</p> <p>Only fill out the fields which are necessary (marked with a red asterisk)</p> </li> <li> <p>Click on Create to create the service </p> <p></p> </li> <li> <p>Give it a second </p> </li> <li> <p>verify the Route: Go back to the Topology and click on the Route sign on the right hand side of the Pod </p> <p></p> </li> </ol> <p>Info</p> <p>You will see that the frontend is loading but you get an 500 Internal Server Error if you open the website. The Internal Server Error occurs, because you only have the frontend deployed and all of the backend is still missing.  So don't worry, we will do this together step by step!</p> <p></p>"},{"location":"Session1/#task-4-scaling","title":"Task 4: Scaling","text":"<p>Scaling the Pod</p> <ol> <li> <p>Scale down the Pod to zero </p> <p></p> </li> <li> <p>Check the Route (Link) to the website - The website should not be reachable</p> <p></p> </li> <li> <p>Scale the Pod up again and verify the link to the website </p> </li> </ol> <p>Info</p> <p>The frontend should be reachable again</p>"},{"location":"Session1/#task-5-microservices-architecture","title":"Task 5: Microservices-Architecture","text":"<p>Create a Microservice Architecture by creating multiple other deployments and connect those by connecting the services</p> <ol> <li>Go into the Github Repository</li> <li>Lets start with the Ad-Service. You can find the Yaml files under the folder adservice</li> <li>Start with the serviceaccount.yml</li> <li>Go to the OpenShift Console and navigate to Administrator - User Management - ServiceAccounts </li> <li>Create a Service Account with the name: adservice in your created namespace (of Task 1)</li> <li>Now it is time to create the Deployment, copy the deployment.yml of the adservice from the GitHub Repository</li> <li>Go back to the OpenShift Console and navigate to: Administrator - Workloads - Deployments</li> <li>Click on Create Deployment </li> <li> <p>Click on YAML view, delete the default content and paste inside your copied deployment.yml</p> <p></p> </li> <li> <p>Lastly, create the regarding Service of the adservice Deployment</p> </li> <li>Copy the service.yml from the adservice folder of the GitHub Repository and switch back to the OpenShift Console</li> <li> <p>Create the service in OpenShift by using the service.yml like we did with the deployment.yml of the adservice </p> <p>Info</p> <p>You can verify, if you go to the Topology and check if your Pod named adservice with the expecting Service is present</p> </li> <li> <p>Now create the cartservice, the checkoutservice and the currencyservice by your own</p> </li> </ol> <p>Hint</p> <p>For the three other microservices you can use the whole manifest.yml file and create the whole microservices (including ServiceAccount, Deployment and Service) all at once. For that navigate to Developer - +Add - Import YAML and paste in the whole manifest file. This saves time  </p> <p></p>"},{"location":"Session1/#solutions-for-troubleshooting","title":"Solutions for Troubleshooting","text":""},{"location":"Session1/#solution-of-task-1","title":"Solution of Task 1","text":"<p>Frontend Pod was not created, but why?!</p> <ol> <li> <p>Check the Error message</p> <p></p> </li> <li> <p>Go to the Deployments (Hint: you can find it, if you switch to the Administrator and under Workloads)</p> </li> <li> <p>Check the ReplicaSet of the frontend Deployment </p> <p></p> </li> <li> <p>Check the Events of the Replicaset</p> <p></p> </li> <li> <p>You got it! You are missing the expected Service Account</p> </li> <li> <p>Create the missing frontend Service Account</p> <p></p> </li> </ol> <p>Info</p> <p>As you can see there are already three Service Accounts. These serviceaccounts are the default Service Accounts. But for our created frontend deployment we do not want to use one of the default once. </p> <p></p> <p>Hint</p> <p>It is important that you name the Service Account exactly as mentioned in you Deployment.yml file</p>"},{"location":"Session2/","title":"2. Hands-On Lab","text":""},{"location":"Session2/#tasks","title":"Tasks","text":""},{"location":"Session2/#task-1-troubleshooting","title":"Task 1: Troubleshooting","text":"<ol> <li>Deploy the Loadgenerator Microservice from the manifest.yml file </li> <li> <p>Click on the Pod and check if it is running</p> <p></p> </li> <li> <p>Check out the Containers inside of the Pod (Init-Containers and the main one)</p> <p></p> </li> <li> <p>Click on the Init-Container frontend-check and read command section and also the fail message</p> <p>Failure</p> <p>Seems like the init-container has a problem!</p> <p></p> </li> <li> <p>Navigate back to the Pod and click on the Events of the Pod </p> <p>Info</p> <p>failed container frontend-check message. The problem lays in the init-container for sure.</p> <p></p> </li> <li> <p>Open the logs of the frontend-check pod and NOT of the main container</p> <p></p> </li> <li> <p>Download the logs to have better insights. Click on raw or on download </p> <p></p> <p>Tip</p> <p>If the Init-Container cannot finish, the main container cannot start! Try to solve it by yourself! If you are not able to solve it by yourself, have a look at the solution section.</p> <p>Success</p> <p>Perfect! You troubleshooted successfully! </p> </li> <li> <p>Check out the logs again of the loadgenerator pod. You should see all of the API-Requests, which the loadgenerator is sending (since the productservicecatalog is created now)</p> </li> <li> <p>Have a look at the boutique webshop, it should look like this:</p> <p></p> </li> <li> <p>Download again the logs of the frontend pod and check it out </p> <p>Hint</p> <p>Newest logs can be found at the bottom. Thereby, you have to scroll down for the latest ones. </p> <p>Info</p> <p>You are maybe still seeing some errors, but none of them are regarding to the missing productservicecatalog. They are regarding due to some more services, which are missing. So do not worry about that for now. </p> </li> </ol>"},{"location":"Session2/#task-2-using-the-cli","title":"Task 2: Using the CLI","text":"<ol> <li> <p>Open the Web Terminal in your OpenShift Namespace. Choose the project in which you would like to open the Web Terminal and click on Start</p> <p></p> </li> <li> <p>Clone the Public GitHub Repository, so you can use the manifest.yml files inside of the cluster </p> <ol> <li> <p>Switch to the Github Repository and copy the https link to the clipboard </p> <p></p> </li> <li> <p>Switch back to the OpenShift UI and enter the CLI </p> </li> <li> <p>Use the following command to clone the public repository</p> </li> </ol> <pre><code>git clone &lt;https://GITHUB-LINK&gt;\n</code></pre> </li> <li> <p>Ensure that the repository was successfully cloned (using Linux-Commands)</p> </li> <li>Enter the e-commerce folder in your CLI</li> <li> <p>Prior to creating the emailservice, verify that you are on the right namespace and logged in as the correct user. Use the oc-CLI-Tools </p> <pre><code>oc project \n\noc projects \n</code></pre> </li> <li> <p>Create the emailservice by using the manifest.yml (stored inside of the emailservice folder) </p> <pre><code>oc apply \u2013f manifest.yml\n</code></pre> <p></p> </li> <li> <p>Verify that the deployment, service and serviceaccount have been created successfully (via CLI)</p> <pre><code># Check the Deployments:\noc get deployment\n\n# Check the Services:\noc get service \n\n# Check the Serviceaccounts:\noc get serviceaccount\n</code></pre> <p></p> </li> <li> <p>Now create the paymentservice microservice</p> <p>Note</p> <p>In this case, there is not an manifest.yml for the paymentservice but we need to create the microservice step-by-step.</p> <ol> <li> <p>Create a serviceaccount, which is named paymentservice via CLI </p> <p></p> </li> <li> <p>Ensure that the serviceaccount with the correct name was successfully created</p> </li> <li> <p>Create the paymentservice deployment like we did before with the emailservice</p> </li> <li> <p>Verify the paymentservice deployment is running </p> </li> <li> <p>Now create the paymentservice service on the CLI using an imperative way. Use the following commands</p> <pre><code>```bash\noc create service clusterip paymentservice --tcp=50051:50051\n```\n6. The Service still needs to be connected to the Deployment and we would like to name the service endpoint\n\n```bash\noc edit service paymentservice\n```\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\nname: paymentservice\nlabels:\n    app: paymentservice\nspec:\ntype: ClusterIP             \nselector:\n    app: paymentservice\nports:\n- name: grpc\n    port: 50051\n    targetPort: 50051\n```\n</code></pre> <p>Note</p> <p>Add the missing parts. </p> </li> </ol> </li> <li> <p>Exit the Command Line and use the OpenShift UI to verify in the Topology that everything was created succesfully! It should look like this: </p> <p></p> </li> </ol>"},{"location":"Session2/#solutions","title":"Solutions","text":""},{"location":"Session2/#solution-task-1","title":"Solution Task 1","text":"<p>Hint</p> <p>There seem to be some problems with the frontend app, as the loadgenerator pod cannot reach it</p> <ol> <li>Check out the logs of the frontend pod in the same way </li> <li> <p>Inside of the logs, search for the keyword error to check whats wrong</p> <p></p> <p>Failure</p> <p>There is an error because the frontend cannot reach the host called productcatalogservice </p> </li> <li> <p>Create the productcatalogservice microservice (you can find the manifest.yml in the Github Repository)</p> </li> <li> <p>After you did that, ensure the loadgenerator pod is running again. Check if the init-container finished and if the main container is running </p> <p></p> <p>Success</p> <p>If everything is running you are doing fine and you can go back to the task 1</p> </li> </ol>"},{"location":"Session3/","title":"3. Hands-On Lab","text":""},{"location":"Session3/#tasks","title":"Tasks","text":""},{"location":"Session3/#task-0-recap","title":"Task 0: Recap","text":"<p>Please recreate the environment from session 2</p> <p>Tip</p> <p>You can use the manifest.yml under the quickstart-into-session3 folder of the GitHub Repository</p> <p>To recap your knowledge until now. You should be able to answer the following questions: </p> <p>Quiz Link</p> <ol> <li> <p>What is the main purpose of a Deployment?</p> <ol> <li>To expose services to the internet</li> <li>To manage the lifecycle of Pods and ensure desired state</li> <li>To store secrets and configuration data</li> <li>To monitor cluster health</li> </ol> </li> <li> <p>What does a ServiceAccount provide in Kubernetes?</p> <ol> <li>A way to expose services externally</li> <li>A method for authenticating users via OAuth</li> <li>An identity for processes running in Pods to interact with the API</li> <li>A configuration for persistent storage</li> </ol> </li> <li> <p>What is the role of a ReplicaSet?</p> <ol> <li>To manage the number of running Pods</li> <li>To route traffic between services</li> <li>To store container images</li> <li>To define access control policies</li> </ol> </li> <li> <p>What is an Operator in OpenShift?</p> <ol> <li>A built-in monitoring tool for Pods</li> <li>A controller that extends Kubernetes to manage applications and their components</li> <li>A user role with elevated permissions</li> <li>A network policy for routing traffic</li> </ol> </li> <li> <p>What is the key difference between a Kubernetes Service and an OpenShift Route?</p> <ol> <li>Services handle internal traffic only, while Routes handle external traffic exclusively</li> <li>Services define how Pods are accessed within the cluster, while Routes provide external HTTP/HTTPS access to Services using OpenShift\u2019s routing layer</li> <li>Services are used for DNS resolution, while Routes manage persistent storage</li> <li>Services and Routes both expose applications externally, but Routes are required for TCP traffic</li> </ol> </li> <li> <p>On which Port does the checkout Pod run? </p> </li> <li> <p>What is the Label of the adservice Service?</p> </li> </ol>"},{"location":"Session3/#task-1-troubleshooting","title":"Task 1: Troubleshooting","text":"<ol> <li>Deploy the shippingservice by using the manifest.yml </li> <li> <p>Check out the Boutique webapp and ensure the service is successfully bound to the applications frontend</p> <ol> <li> <p>Enter the shopping cart (the frontend needs the shippingservice as well as the cartservice to show the shopping cart informations)</p> <p></p> <p>Failure</p> <p>Seems like the frontend service cannot build up a connection to the shipping service</p> </li> </ol> </li> <li> <p>Find out about the problem and troubleshoot! </p> <p>Success</p> <p>After you fixed the problem, you can validate that it works: </p> </li> <li> <p>Navigate to the topology and check out your changes</p> <ol> <li>Click on the route and then in the Boutique Shop on the Shoppingcart symbol</li> <li>The frontend should be able to connect to the shipping service. </li> <li> <p>It should look like this: </p> <p></p> </li> </ol> <p>Hint</p> <p>Maybe it is neccessary to empty the cache of your browser!</p> </li> </ol>"},{"location":"Session3/#task-2-troubleshooting","title":"Task 2: Troubleshooting","text":"<ol> <li>Create the recommendationservice Deployment</li> <li>Create the recommendation Service</li> <li> <p>Ensure the Deployment and the Service are connected together </p> <p></p> <p>Failure</p> <p>Does it look like on the screenshot? No?! Then there is probably something wrong.</p> </li> <li> <p>Troubleshoot!</p> </li> </ol>"},{"location":"Session3/#solutions","title":"Solutions","text":""},{"location":"Session3/#solution-task-1","title":"Solution Task 1","text":"<ol> <li>The error message says that the frontend could not establish a connection to 172.31.128.46:50000</li> <li>Check if the IP and the Port is the correct one of the shipping service</li> <li> <p>Navigate to the service of the shipping deployment, because the service provides an static endpoint for the shipping deployment</p> <p>Warning</p> <p>Seems like the IP-addresse is the right one, but the Port of the Service is not 50000, but 50051! Here is a Port mismatch!</p> </li> <li> <p>Fix This!</p> </li> <li> <p>Navigate to the frontend deployment and check out the environment variables, which are set for the frontend deployment</p> <p></p> <ol> <li>The port is wrong</li> <li>Correct the port and click on save </li> </ol> <p>Tip</p> <p>Wait a bit... The old pod of the frontend gets deleted and a new pod with the updated configs and environment variables comes up</p> </li> </ol>"},{"location":"Session3/#solutions-task-2","title":"Solutions Task 2","text":"<p>Info</p> <p>Deployments and Services are connected to each other by using labels </p> <ol> <li>Check the label, which is assigned to the recommendation deployment</li> <li>Compare this label with the used selector in the recommendation service </li> <li>Correct the selector in the recommendation service to match the label</li> <li>Now, ensure again if the Deployment is bound to the Service</li> </ol>"},{"location":"Session4/","title":"4. Hands-On Lab","text":""},{"location":"Session4/#tasks","title":"Tasks","text":""},{"location":"Session4/#task-0-recap-quiz","title":"Task 0: Recap Quiz","text":"<p>To recap your knowledge until now. You should be able to answer the following questions. You can access the Quiz under the following link: </p> <p>Recap Quiz</p> <ol> <li> <p>How does a Kubernetes Service in OpenShift know which Pods to route traffic to?</p> <ol> <li>It uses the Pod's IP address directly</li> <li>It matches the Pod's labels with its selector</li> <li>It queries the Deployment for Pod information</li> <li>It uses the container image name as a reference</li> </ol> </li> <li> <p>What happens if a Deployment in OpenShift references an image that does not exist in the ImageStream?</p> <ol> <li>The Deployment will automatically build the image</li> <li>The Pod will start but fail during runtime</li> <li>The Pod will fail to start due to ImagePull errors</li> <li>OpenShift will fallback to a default image</li> </ol> </li> <li> <p>Which of the following best describes the role of an ImageStream in OpenShift </p> <ol> <li>It stores container images in the internal registry</li> <li>It defines the build strategy for applications</li> <li>It acts as a reference point for image versions and triggers</li> <li>It manages network access between Pods </li> </ol> </li> <li> <p>Which of the following statements about Deployments in OpenShift is true?</p> <ol> <li>A Deployment directly manages Pods without ReplicaSets </li> <li>A Deployment must always be paired with a BuildConfig</li> <li>A Deplyoment can be triggered by changes in an ImageStream</li> <li>A Deployment cannot be scaled manually </li> </ol> </li> <li> <p>In OpenShift, what is the correct relationship between a Route and a Service?</p> <ol> <li>A Route exposes a Service, which then routes traffic to matching Pods</li> <li>A Route exposes a Deployment directly to external traffic</li> <li>A Route forwards to a Pod based on its IP address</li> <li>A Route must reference an ImageStream to function correctly </li> </ol> </li> </ol>"},{"location":"Session4/#task-1-imagestreams-and-deployment","title":"Task 1: ImageStreams and Deployment","text":"<ol> <li> <p>Create a Imagestream which should refer an nginx image from Quay.io </p> <p>Tip</p> <p>There is a template in the GitHub in the folder: session4/nginx</p> <ol> <li>Create a deployment based on that newly created Imagestream. </li> <li>The Deployment should have the following characteristics:<ul> <li>name: nginx-unprivileged </li> <li>port: 8080</li> <li>label: app: nginx-unprivileged</li> <li>image: REFERENCE-TO-IMAGESTREAM:TAG</li> </ul> </li> </ol> <p>Hint</p> <p>You can create the Deployment by using the survey or by using the YAML input field. If you would like to use the YAML input, it can be helpful to reference the Kubernetes documentation: Deployments in Kubernetes</p> </li> <li> <p>Create a Service names nginx-unprivileged of the Deployment</p> <p>Hint</p> <p>Keep in mind, that you are connecting the correct Deployment to yout service and to set the targetPort correct!</p> </li> <li> <p>Create a Route of the Service to access the nginx Deployment from outside the cluster </p> </li> <li> <p>Verify that the Deployment, Service and Route works correctly by entering the Route. It should look like this: </p> <p></p> </li> </ol>"},{"location":"Session4/#task-2-deploy-from-containerfile","title":"Task 2: Deploy from Containerfile","text":"<ol> <li>Create a ImageStream </li> <li> <p>Create a BuildConfig by using the session4/python_app/buildconfig.yml file</p> <p>Hint</p> <p>You need to adjust some of the fields in the BuildConfig. </p> </li> <li> <p>Start a Build </p> </li> <li> <p>Verify that the Image is tagged to your created ImageStream </p> <p></p> </li> <li> <p>Create a Deployment of the python-app, which uses the newly tagged image of the ImageStream </p> <ul> <li>containerPort: 8080</li> <li>label: app=python</li> </ul> </li> <li> <p>Create a Service of the python-app Deployment </p> <p>Hint</p> <p>Keep in mind, that you need to set the correct label and targetPort</p> </li> <li> <p>Create a Route to access the python-app also from outside the cluster</p> <p>Success</p> <p>If everything works correctly, you should see the following message. </p> <p></p> </li> </ol>"},{"location":"Session4/#task-3-setting-up-prometheus-and-scraping-logs-from-the-python-app","title":"Task 3: Setting up Prometheus and Scraping logs from the python-app","text":"<p>We would now like to scrape metrics from the python-app in a Prometheus server.</p> <p>The application has already defined an endpoint /metrics in the container file and in the app.py file, which runs on port 8000.</p> <ol> <li> <p>Make this Endpoint of the python-app accessible from inside and outside the cluster (Create service and route). Depending on the names you gave, it should like similar to this:</p> <p>Hint</p> <p>You already have created the Deployment, a Service and a Route, which listens on Port 8080.  Now you should create a Service and a Route to the same Deployment but to the endpoint on port 8000 </p> <p></p> </li> </ol> <p>Now we can start to deploy the Prometheus server:</p> <ol> <li> <p>Create a ConfigMap, which should be consumed from the Prometheus server (manifest file can be found under the session4/prometheus/ folder in the GitHub)</p> <p>Info</p> <p>Contains the configurations for the endpoint from which the metrics are to be obtained (python-app) and, for example, the intervals at which the metrics are to be scraped</p> </li> <li> <p>Create an imagestream, which refers to an Prometheus image from Quay.io</p> <p></p> </li> <li> <p>Create a Deployment which uses the image from the newly created ImageStream </p> <p>Note</p> <p>use the deployment.yml template, which can be found in the session4/prometheus folder on GitHub</p> </li> <li> <p>Create a Service and a Route for the Prometheus server to acces it:</p> <p></p> </li> <li> <p>Verify that the Prometheus is scraping data from the python-app. In the Prometheus UI click on Status and then on Target health: </p> <p></p> </li> </ol>"},{"location":"Session5/","title":"5. Hands-On Lab","text":""},{"location":"Session5/#tasks","title":"Tasks","text":""},{"location":"Session5/#task-0-recap-task","title":"Task 0: Recap Task","text":"<p>Let's start with a short recap task that revisits what we learned in session 4.  We will start by deploying the Python application from task 2 again. You can find the corresponding manifest files in the Github folder session5_task0.</p> <ol> <li>Deploy the first manifest file manifest1.yml, it contains the yaml files for the Imagestream and the BuildConfig</li> <li> <p>Deploy the second manifest file manifest2.yml, which contains the yaml file for the Deployment, Service and the Route</p> <p>Hint</p> <p>You need to adjust the name of the image to refence the correct Imagestream </p> <p>Now we would now like to scrape metrics from the python application in a Prometheus server.</p> <p>The application has already defined an endpoint /metrics in the container file and in the app.py file, which runs on port 8000.</p> </li> <li> <p>Make this Endpoint of the python-app accessible from inside and outside the cluster (Create service and route). Depending on the names you gave, it should like similar to this:</p> <p>Hint</p> <p>You already have created the Deployment, a Service and a Route, which listens on Port 8080.  Now you should create a Service and a Route to the same Deployment but to the endpoint on port 8000</p> <p></p> <p>Now we can start to deploy the Prometheus server:</p> </li> <li> <p>Create a ConfigMap, which should be consumed from the Prometheus server (manifest file can be found under the session4/prometheus/ folder in the GitHub)</p> <p>Info</p> <p>Contains the configurations for the endpoint from which the metrics are to be obtained (python-app) and, for example, the intervals at which the metrics are to be scraped</p> </li> <li> <p>Create an Imagestream, which refers to an Prometheus image from Quay.io</p> <p></p> <p>Hint</p> <p>You can find the manifest file in the folder in the GitHub. But you need to adjust the image name!</p> </li> <li> <p>Create a Deployment which uses the image from the newly created ImageStream </p> <p>Note</p> <p>use the deployment.yml template, which can be found in the session4/prometheus folder on GitHub and asjust the reference-path to the newly created ImageStream. </p> <p>Warning</p> <p>Probably, you will get an error. Read the logs of the failed pod.  The problem lays in the Hostname which you entered in the ConfigMap --&gt; Check it out and fix the issue!</p> </li> <li> <p>Create a Service and a Route for the Prometheus server to acces it:</p> <p></p> </li> <li> <p>Verify that the Prometheus is scraping data from the python-app. In the Prometheus UI click on Status and then on Target health: </p> <p></p> </li> </ol>"},{"location":"Session5/#task-1-secrets-and-configmaps","title":"Task 1: Secrets and ConfigMaps","text":"<ol> <li> <p>Create a Secret with name \"wealthapp\", that contains the following keys and values:</p> <p>Tip</p> <p>You can do this directly in the WebUI, which shows a form for creating secrets. If you need further information about secrets, refer to the Secret documentation.</p> </li> </ol> Key Value DB_USERNAME wealthapp DB_PASSWORD eatTheRich DB_DATABASE revenue <ol> <li> <p>Create a ConfigMap with name \"wealthapp\", that contains the following keys and values:</p> <p>Warning</p> <p>The last two keys contain multiline data. Preserve the newlines in the ConfigMap, so that the corresponding files can be used as provided here. If you need further information about ConfigMaps, refer to the ConfigMap documentation.</p> </li> </ol> Key Value API_HOST backend API_PORT \"8080\" DB_HOST database cgi-default-app.conf &lt;Directory \"/var/www/html\"&gt;  Options +ExecCGI  DirectoryIndex /cgi-bin/app.py&lt;/Directory&gt; cgi-default-data.conf &lt;Directory \"/var/www/html\"&gt;  Options +ExecCGI  DirectoryIndex /cgi-bin/data.py&lt;/Directory&gt; <ol> <li> <p>Look at your Secret and ConfigMap in the WebUI. Inspect their YAML representation and check, if the values are set how you expect it.</p> <p>Tip</p> <p>As some values are base64-encoded, you might need to decode the values from the Secret/ConfigMap with the command <code>echo \"&lt;insert encoded text&gt; | base64 -d</code>.</p> </li> </ol>"},{"location":"Session5/#task-2-adding-environment-variables-form-secretsconfigmaps-to-deployments","title":"Task 2: Adding environment variables form Secrets/ConfigMaps to Deployments","text":"<ol> <li> <p>Deploy the resource manifests, that are provided in the repository under <code>session5_task1_2</code>, with the 3 components \"frontend\", \"backend\" and \"database\".</p> <p>Hint</p> <p>Keep in mind, that you are using your own images with the provided BuildConfigs. Thus you need to place the correct references to your ImageStreams in the Deployment manifests. The database deployment has 2 mentions of the image, that you need to replace.</p> <ol> <li>Check your Deployments, if they are healthy. Then check the application by opening the Route URL. Do you see any errors? Diagnose them.</li> </ol> <p>Hint</p> <p>You might have to wait a moment for the Builds to finish. You can check the build status and logs to verify this.</p> </li> <li> <p>Provide the needed environment variables to your Deployments. You can look into the YAML resource definition or at the <code>Environment</code> tab of the Deployments. The Deployments need the follwing environment variables:</p> </li> </ol> Deployment Environment variable frontend API_HOST, API_PORT backend DB_HOST, DB_USERNAME, DB_PASSWORD, DB_DATABASE <ol> <li> <p>Verify, that the application now works correctly. It should look like this:</p> <p></p> </li> </ol>"},{"location":"Session5/#task-3-mounting-files-from-configmaps-and-secrets-in-deployments","title":"Task 3: Mounting files from ConfigMaps and Secrets in Deployments","text":"<p>Our webapp got an update with new requirements.</p> <ol> <li> <p>Change the BuildConfigs for the <code>frontend</code> and <code>backend</code> components, so that the <code>contextDir</code> now points to <code>session5_task3/build_directories/frontend</code> and <code>session5_task3/build_directories/backend</code> respectively and start the builds. After the builds finished, put the new image digest (the SHA Identifier) from the ImageStream into the corresponding deployments to update the used image.</p> </li> <li> <p>Trigger a new Build for the <code>frontend</code> and <code>backend</code> BuildConfigs and check, if the Deployments are still healthy. Do you see any errors?</p> <p>Hint</p> <p>You might have to wait a moment for the Builds to finish. You can check the build status and logs to verify this.</p> <p>Hint</p> <p>You can look at the events and the logs of each Pod.</p> </li> <li> <p>Mount the needed file from the ConfigMap in the corresponding Deployment by editing the YAML resource definitions.</p> </li> </ol> Deployment Key in ConfigMap Path to mount the file to frontend cgi-default-app.conf /etc/httpd/conf.d/cgi-default-app.conf backend cgi-default-data.conf /etc/httpd/conf.d/cgi-default-data.conf <ol> <li>Verify, that the updated application now runs as intended. Check each Deployment to be healthy and access the application via its Route.</li> </ol>"},{"location":"Session6/","title":"5. Hands-On Lab","text":""},{"location":"Session6/#tasks","title":"Tasks","text":""},{"location":"Session6/#task-0-recap-task","title":"Task 0: Recap Task","text":"<ol> <li> <p>Create a Secret with name \"wealthapp\", that contains the following keys and values:</p> <p>Tip</p> <p>You can do this directly in the WebUI, which shows a form for creating secrets. If you need further information about secrets, refer to the Secret documentation.</p> </li> </ol> Key Value DB_USERNAME wealthapp DB_PASSWORD eatTheRich DB_DATABASE revenue <ol> <li>Create a ConfigMap with name \"wealthapp\", that contains the following keys and values:</li> </ol> Key Value API_HOST backend API_PORT \"8080\" DB_HOST database <ol> <li> <p>Deploy the manifests from the repository under session6/backend, frontend and database. Be sure to first create the ImageStream and BuildConfig, then the rest of the manifests.</p> <p>Tip</p> <p>Keep in mind, that you need to replace the image references in the deployment manifests with the image repository of your specific ImageStream</p> </li> <li> <p>Check all deployments for their health and if you can reach the web application through the URL provided by the Route.</p> <p>Warning</p> <p>Keep in mind, that we are creating an unsecured route, meaning http, not https. Your browser might automatically redirect to https, when clicking on the link of the route. In that case you need to manually change the URL in the browser back to http.</p> </li> </ol>"},{"location":"Session6/#task-1-ephemeral-storage","title":"Task 1: Ephemeral Storage","text":"<ol> <li> <p>Use the form at the top of the webapp to add a new data line to the database. You can choose whatever values you see fit.</p> </li> <li> <p>Load the URL again and see, if the added dataline is still there.</p> </li> <li> <p>Go into the Openshift WebUI under Workloads -&gt; Deployments, choose the \"database\" deployment from the list and then click on the \"Pods\" tab for this deployment. Delete the existing database Pod and watch it being recreated by Openshift.</p> </li> <li> <p>When the new database Pod is ready again, load the webapp again. Is the new dataline still there?</p> </li> </ol>"},{"location":"Session6/#task-2-persistent-storage","title":"Task 2: Persistent Storage","text":"<ol> <li>We want to persist the database of our webapp, so that it can survive restarts of the database Pod. In the database Deployment click on the \"Actions\" button and add storage to the deployment. For this choose to create a new PVC (Persistent Volume Claim) and mount it into the container with the following properties (leave non-mentioned properties with their default value):</li> </ol> Property Value PVC name wealthapp Access mode Single user (RWO) Size 1GiB Mount path /var/lib/mysql/data <ol> <li> <p>Save and wait until the database Deployment is ready again.</p> </li> <li> <p>Reload the webapp and use the form at the top of the webapp to again add a new dataline with whatever values you see fit. Check if the new dataline appears in the list after you clicked on submit.</p> </li> <li> <p>Go into the Openshift WebUI under Workloads -&gt; Deployments, choose the \"database\" deployment from the list and then click on the \"Pods\" tab for this deployment. Delete the existing database Pod and watch it being recreated by Openshift.</p> </li> <li> <p>When the database Deployment is ready, reload the webapp again. Is the new dataline still there?</p> </li> </ol>"},{"location":"Session7/","title":"5. Hands-On Lab","text":""},{"location":"Session7/#tasks","title":"Tasks","text":""},{"location":"Session7/#task-1-deploying-jenkins","title":"Task 1: Deploying Jenkins","text":"<p>To increase the speed of development and decrease the time to market, the dev team wants to deploy the wealthapp via a Jenkins Pipeline on Openshift. You are tasked to deploy Jenkins in a namespace.</p> <ol> <li> <p>In the Developer Console go to the menu entry \"+Add\" and choose \"All services\" from the Developer Catalog.</p> </li> <li> <p>Search for \"Jenkins\", click on the one first with persistent storage and then on \"Instantiate Template\".</p> </li> <li> <p>In the resulting form set the \"Volume Capacity\" to \"3Gi\". Leave the rest with its default values und click \"Create\". Wait for the Jenkins Pod to get ready.</p> <p>Note</p> <p>The used Jenkins template still uses the deprecated DeploymentConfig resource, which basically has the same functionality as the Deployment resource.</p> </li> <li> <p>Open the Jenkins WebUI from the URL of the jenkins Route, login with your Openshift credentials and Allow the selected permissions, so that Openshift can handle the authentication for Jenkins.</p> </li> </ol>"},{"location":"Session7/#task-2-configure-the-jenkins-pipeline-and-trigger-a-build","title":"Task 2: Configure the Jenkins Pipeline and trigger a build","text":"<p>The dev team has build a working prototype of a Pipeline for deploying the wealthapp. You are tasked with adding it to your Jenkins instance and testing it.</p> <ol> <li> <p>In the Jenkins WebUI create a Job with the name \"wealthapp\" as a Pipeline.</p> </li> <li> <p>In the resulting form paste the Jenkins pipeline \"wealthapp_pipeline\" from the session7 directory in the training repository into the Pipeline script field and save the pipeline.</p> </li> <li> <p>Start the newly created pipeline and watch how it executes.</p> </li> <li> <p>Check the console output of the finished pipeline. What happens there?</p> </li> <li> <p>Inspect the pipeline definition, that you copied from the training repository. What is each stage doing?</p> </li> </ol>"},{"location":"Session7/#task-3-changing-the-pipeline-and-troubleshooting","title":"Task 3: Changing the pipeline and troubleshooting","text":"<p>To facilitate future staging of the wealthapp, the ops team wants to also tag every image, that is build via the pipeline, with the tag \"staging\". This ensures, that the build image version can be used for a future pipeline, promoting it though to the testing and production stage.</p> <ol> <li> <p>Add a new stage named \"tagging\" at the end of the pipeline definition. Use the other stages for reference on how to build up a stage for execution with openshift. For each of the three images, that is build for the wealthapp, add the line (and replace \"\" with the name of the corresponding Imagestream): <pre><code>openshift.tag(\"&lt;imagename&gt;:latest\", \"&lt;imagename&gt;:staging\")\n</code></pre> <li> <p>Save and let the pipeline run. Look at the console output. Is everything working correctly? If not, why?</p> </li> <li> <p>Fix the pipeline by adding the following code snippet directly before the tagging lines:</p> <p> Code fix: <pre><code>echo \"Waiting for builds to finish...\"\ndef build = openshift.selector('build', [app: 'wealthapp'])\ntimeout(time: 10, unit: 'MINUTES') {\n    build.untilEach {\n        def phase = it.object().status.phase\n        echo \"Build ${it.name()} is in phase: ${phase}\"\n        return (phase == \"Complete\" || phase == \"Failed\" || phase == \"Cancelled\")\n    }\n}\necho \"tagging\"\n</code></pre> <p>This code snippet will wait for the builds to finish, before trying to tag the resulting images.</p> <li> <p>Test the pipeline again. Does it work now? Check in the Openshift WebUI, if you can find the \"staging\" tags in the Imagestreams.</p> </li>"}]}